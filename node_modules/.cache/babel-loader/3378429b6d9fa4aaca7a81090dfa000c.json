{"ast":null,"code":"var _slicedToArray = require(\"/Users/isaac/Desktop/sheets-roll/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"/Users/isaac/Desktop/sheets-roll/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\n// Generated by CoffeeScript 2.3.2\n// # CSV Parser\n// This module provides a CSV parser tested and used against large datasets. Over the year, it has been enhance and is now full of useful options.\n// Please look at the [project website](https://csv.js.org/parse/) for additional information.\nvar Parser, StringDecoder, isObjLiteral, stream, util;\nstream = require('stream');\nutil = require('util');\n\nvar _require = require('string_decoder');\n\nStringDecoder = _require.StringDecoder;\n\n// ## Usage\n// Callback approach, for ease of use:   \n// `parse(data, [options], callback)`     \n// [Node.js Stream API](http://nodejs.org/api/stream.html), for maximum of power:   \n// `parse([options], [callback])`   \nmodule.exports = function () {\n  var callback, called, chunks, data, err, options, parser;\n\n  if (arguments.length === 3) {\n    data = arguments[0];\n    options = arguments[1];\n    callback = arguments[2];\n\n    if (typeof callback !== 'function') {\n      throw Error(\"Invalid callback argument: \".concat(JSON.stringify(callback)));\n    }\n\n    if (!(typeof data === 'string' || Buffer.isBuffer(arguments[0]))) {\n      return callback(Error(\"Invalid data argument: \".concat(JSON.stringify(data))));\n    }\n  } else if (arguments.length === 2) {\n    // 1st arg is data:string or options:object\n    if (typeof arguments[0] === 'string' || Buffer.isBuffer(arguments[0])) {\n      data = arguments[0];\n    } else if (isObjLiteral(arguments[0])) {\n      options = arguments[0];\n    } else {\n      err = \"Invalid first argument: \".concat(JSON.stringify(arguments[0]));\n    } // 2nd arg is options:object or callback:function\n\n\n    if (typeof arguments[1] === 'function') {\n      callback = arguments[1];\n    } else if (isObjLiteral(arguments[1])) {\n      if (options) {\n        err = 'Invalid arguments: got options twice as first and second arguments';\n      } else {\n        options = arguments[1];\n      }\n    } else {\n      err = \"Invalid first argument: \".concat(JSON.stringify(arguments[1]));\n    }\n\n    if (err) {\n      if (!callback) {\n        throw Error(err);\n      } else {\n        return callback(Error(err));\n      }\n    }\n  } else if (arguments.length === 1) {\n    if (typeof arguments[0] === 'function') {\n      callback = arguments[0];\n    } else {\n      options = arguments[0];\n    }\n  }\n\n  if (options == null) {\n    options = {};\n  }\n\n  parser = new Parser(options);\n\n  if (data != null) {\n    process.nextTick(function () {\n      parser.write(data);\n      return parser.end();\n    });\n  }\n\n  if (callback) {\n    called = false;\n    chunks = options.objname ? {} : [];\n    parser.on('readable', function () {\n      var chunk, results;\n      results = [];\n\n      while (chunk = parser.read()) {\n        if (options.objname) {\n          results.push(chunks[chunk[0]] = chunk[1]);\n        } else {\n          results.push(chunks.push(chunk));\n        }\n      }\n\n      return results;\n    });\n    parser.on('error', function (err) {\n      called = true;\n      return callback(err);\n    });\n    parser.on('end', function () {\n      if (!called) {\n        return callback(null, chunks);\n      }\n    });\n  }\n\n  return parser;\n}; // ## `Parser([options])`\n// Options are documented [here](http://csv.js.org/parse/options/).\n\n\nParser = function Parser() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var base, base1, base10, base11, base12, base13, base14, base15, base16, base17, base2, base3, base4, base5, base6, base7, base8, base9, k, v; // @options = options\n\n  this.options = {};\n\n  for (k in options) {\n    v = options[k];\n    this.options[k] = v;\n  }\n\n  this.options.objectMode = true;\n  stream.Transform.call(this, this.options);\n\n  if ((base = this.options).rowDelimiter == null) {\n    base.rowDelimiter = null;\n  }\n\n  if (typeof this.options.rowDelimiter === 'string') {\n    this.options.rowDelimiter = [this.options.rowDelimiter];\n  }\n\n  if ((base1 = this.options).delimiter == null) {\n    base1.delimiter = ',';\n  }\n\n  if (this.options.quote !== void 0 && !this.options.quote) {\n    this.options.quote = '';\n  }\n\n  if ((base2 = this.options).quote == null) {\n    base2.quote = '\"';\n  }\n\n  if ((base3 = this.options).escape == null) {\n    base3.escape = '\"';\n  }\n\n  if ((base4 = this.options).columns == null) {\n    base4.columns = null;\n  }\n\n  if ((base5 = this.options).comment == null) {\n    base5.comment = '';\n  }\n\n  if ((base6 = this.options).objname == null) {\n    base6.objname = false;\n  }\n\n  if ((base7 = this.options).trim == null) {\n    base7.trim = false;\n  }\n\n  if ((base8 = this.options).ltrim == null) {\n    base8.ltrim = false;\n  }\n\n  if ((base9 = this.options).rtrim == null) {\n    base9.rtrim = false;\n  }\n\n  if (this.options.auto_parse != null) {\n    this.options.cast = this.options.auto_parse;\n  }\n\n  if ((base10 = this.options).cast == null) {\n    base10.cast = false;\n  }\n\n  if (this.options.auto_parse_date != null) {\n    this.options.cast_date = this.options.auto_parse_date;\n  }\n\n  if ((base11 = this.options).cast_date == null) {\n    base11.cast_date = false;\n  }\n\n  if (this.options.cast_date === true) {\n    this.options.cast_date = function (value) {\n      var m;\n      m = Date.parse(value);\n\n      if (!isNaN(m)) {\n        value = new Date(m);\n      }\n\n      return value;\n    };\n  }\n\n  if ((base12 = this.options).relax == null) {\n    base12.relax = false;\n  }\n\n  if ((base13 = this.options).relax_column_count == null) {\n    base13.relax_column_count = false;\n  }\n\n  if ((base14 = this.options).skip_empty_lines == null) {\n    base14.skip_empty_lines = false;\n  }\n\n  if ((base15 = this.options).max_limit_on_data_read == null) {\n    base15.max_limit_on_data_read = 128000;\n  }\n\n  if ((base16 = this.options).skip_lines_with_empty_values == null) {\n    base16.skip_lines_with_empty_values = false;\n  }\n\n  if ((base17 = this.options).skip_lines_with_error == null) {\n    base17.skip_lines_with_error = false;\n  } // Counters\n  // lines = count + skipped_line_count + empty_line_count\n\n\n  this.lines = 0; // Number of lines encountered in the source dataset\n\n  this.count = 0; // Number of records being processed\n\n  this.skipped_line_count = 0; // Number of records skipped due to errors\n\n  this.empty_line_count = 0; // Number of empty lines\n  // Constants\n\n  this.is_int = /^(\\-|\\+)?([1-9]+[0-9]*)$/; // @is_float = /^(\\-|\\+)?([0-9]+(\\.[0-9]+)([eE][0-9]+)?|Infinity)$/\n  // @is_float = /^(\\-|\\+)?((([0-9])|([1-9]+[0-9]*))(\\.[0-9]+)([eE][0-9]+)?|Infinity)$/\n\n  this.is_float = function (value) {\n    return value - parseFloat(value) + 1 >= 0; // Borrowed from jquery\n  }; // Internal private state\n\n\n  this._ = {\n    decoder: new StringDecoder(),\n    quoting: false,\n    commenting: false,\n    field: null,\n    nextChar: null,\n    closingQuote: 0,\n    line: [],\n    chunks: [],\n    rawBuf: '',\n    buf: '',\n    rowDelimiterMaxLength: this.options.rowDelimiter ? Math.max.apply(Math, _toConsumableArray(this.options.rowDelimiter.map(function (v) {\n      return v.length;\n    }))) : void 0,\n    lineHasError: false,\n    isEnded: false\n  };\n  return this;\n}; // ## Internal API\n// The Parser implement a [`stream.Transform` class](https://nodejs.org/api/stream.html#stream_class_stream_transform).\n// ### Events\n// The library extends Node [EventEmitter][event] class and emit all the events of the Writable and Readable [Stream API](http://nodejs.org/api/stream.html). \n\n\nutil.inherits(Parser, stream.Transform); // For extra flexibility, you can get access to the original Parser class: `require('csv-parse').Parser`.\n\nmodule.exports.Parser = Parser; // ### `_transform(chunk, encoding, callback)`\n// * `chunk` Buffer | String   \n//   The chunk to be transformed. Will always be a buffer unless the decodeStrings option was set to false.\n// * `encoding` String   \n//   If the chunk is a string, then this is the encoding type. (Ignore if decodeStrings chunk is a buffer.)\n// * `callback` Function   \n//   Call this function (optionally with an error argument) when you are done processing the supplied chunk.\n// Implementation of the [`stream.Transform` API](https://nodejs.org/api/stream.html#stream_class_stream_transform)\n\nParser.prototype._transform = function (chunk, encoding, callback) {\n  var _this = this;\n\n  return setImmediate(function () {\n    var err;\n\n    if (chunk instanceof Buffer) {\n      chunk = _this._.decoder.write(chunk);\n    }\n\n    err = _this.__write(chunk, false);\n\n    if (err) {\n      return _this.emit('error', err);\n    }\n\n    return callback();\n  });\n};\n\nParser.prototype._flush = function (callback) {\n  return callback(this.__flush());\n};\n\nParser.prototype.__flush = function () {\n  var err;\n  err = this.__write(this._.decoder.end(), true);\n\n  if (err) {\n    return err;\n  }\n\n  if (this._.quoting) {\n    err = this.error(\"Quoted field not terminated at line \".concat(this.lines + 1));\n    return err;\n  }\n\n  if (this._.line.length > 0) {\n    return this.__push(this._.line);\n  }\n};\n\nParser.prototype.__push = function (line) {\n  var call_column_udf, columnName, columns, err, field, i, j, len, lineAsColumns, record;\n\n  if (this._.isEnded) {\n    return;\n  }\n\n  if (this.options.skip_lines_with_empty_values && line.join('').trim() === '') {\n    return;\n  }\n\n  record = null;\n\n  if (this.options.columns === true) {\n    this.options.columns = line;\n    return;\n  } else if (typeof this.options.columns === 'function') {\n    call_column_udf = function call_column_udf(fn, line) {\n      var columns, err;\n\n      try {\n        columns = fn.call(null, line);\n        return [null, columns];\n      } catch (error) {\n        err = error;\n        return [err];\n      }\n    };\n\n    var _call_column_udf = call_column_udf(this.options.columns, line);\n\n    var _call_column_udf2 = _slicedToArray(_call_column_udf, 2);\n\n    err = _call_column_udf2[0];\n    columns = _call_column_udf2[1];\n\n    if (err) {\n      return err;\n    }\n\n    this.options.columns = columns;\n    return;\n  }\n\n  if (!this._.line_length && line.length > 0) {\n    this._.line_length = this.options.columns ? this.options.columns.length : line.length;\n  } // Dont check column count on empty lines\n\n\n  if (line.length === 1 && line[0] === '') {\n    this.empty_line_count++;\n  } else if (line.length !== this._.line_length) {\n    // Dont check column count with relax_column_count\n    if (this.options.relax_column_count) {\n      this.count++;\n      this.skipped_line_count++;\n    } else if (this.options.columns != null) {\n      // Suggest: Inconsistent header and column numbers: header is 1 and number of columns is 1 on line 1\n      err = this.error(\"Number of columns on line \".concat(this.lines, \" does not match header\"));\n      return err;\n    } else {\n      err = this.error(\"Number of columns is inconsistent on line \".concat(this.lines));\n      return err;\n    }\n  } else {\n    this.count++;\n  }\n\n  if (this.options.columns != null) {\n    lineAsColumns = {};\n\n    for (i = j = 0, len = line.length; j < len; i = ++j) {\n      field = line[i];\n      columnName = this.options.columns[i];\n\n      if (columnName === void 0 || columnName === null || columnName === false) {\n        continue;\n      }\n\n      if (typeof columnName !== 'string') {\n        throw Error(\"Invalid column name \".concat(JSON.stringify(columnName)));\n      }\n\n      lineAsColumns[columnName] = field;\n    }\n\n    if (this.options.objname) {\n      record = [lineAsColumns[this.options.objname], lineAsColumns];\n    } else {\n      record = lineAsColumns;\n    }\n  } else {\n    record = line;\n  }\n\n  if (this.count < this.options.from) {\n    return;\n  }\n\n  if (this.options.raw) {\n    this.push({\n      raw: this._.rawBuf,\n      row: record\n    });\n    this._.rawBuf = '';\n  } else {\n    this.push(record);\n  }\n\n  if (this.listenerCount('record')) {\n    this.emit('record', record);\n  } // When to is reached set ignore any future calls\n\n\n  if (this.count >= this.options.to) {\n    this._.isEnded = true;\n    return this.push(null);\n  }\n\n  return null;\n};\n\nParser.prototype.__write = function (chars, end) {\n  var _this2 = this;\n\n  var areNextCharsDelimiter, areNextCharsRowDelimiters, cast, char, err, escapeIsQuote, i, isDelimiter, isEscape, isNextCharAComment, isNextCharTrimable, isQuote, isRowDelimiter, isRowDelimiterLength, is_float, is_int, l, ltrim, nextCharPos, ref, ref1, ref2, ref3, ref4, ref5, ref6, remainingBuffer, rowDelimiter, rtrim, wasCommenting;\n\n  is_int = function is_int(value) {\n    if (typeof _this2.is_int === 'function') {\n      return _this2.is_int(value);\n    } else {\n      return _this2.is_int.test(value);\n    }\n  };\n\n  is_float = function is_float(value) {\n    if (typeof _this2.is_float === 'function') {\n      return _this2.is_float(value);\n    } else {\n      return _this2.is_float.test(value);\n    }\n  };\n\n  cast = function cast(value) {\n    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!_this2.options.cast) {\n      return value;\n    }\n\n    if (context.quoting == null) {\n      context.quoting = !!_this2._.closingQuote;\n    }\n\n    if (context.lines == null) {\n      context.lines = _this2.lines;\n    }\n\n    if (context.count == null) {\n      context.count = _this2.count;\n    }\n\n    if (context.index == null) {\n      context.index = _this2._.line.length;\n    } // context.header ?= if @options.column and @lines is 1 and @count is 0 then true else false\n\n\n    if (context.header == null) {\n      context.header = _this2.options.columns === true;\n    }\n\n    if (context.column == null) {\n      context.column = Array.isArray(_this2.options.columns) ? _this2.options.columns[context.index] : context.index;\n    }\n\n    if (typeof _this2.options.cast === 'function') {\n      return _this2.options.cast(value, context);\n    }\n\n    if (is_int(value)) {\n      value = parseInt(value);\n    } else if (is_float(value)) {\n      value = parseFloat(value);\n    } else if (_this2.options.cast_date) {\n      value = _this2.options.cast_date(value, context);\n    }\n\n    return value;\n  };\n\n  ltrim = this.options.trim || this.options.ltrim;\n  rtrim = this.options.trim || this.options.rtrim;\n  chars = this._.buf + chars;\n  l = chars.length;\n  i = 0;\n\n  if (this.lines === 0 && 0xFEFF === chars.charCodeAt(0)) {\n    // Strip BOM header\n    i++;\n  }\n\n  while (i < l) {\n    // Ensure we get enough space to look ahead\n    if (!end) {\n      remainingBuffer = chars.substr(i, l - i); // (i+1000 >= l) or\n      // Skip if the remaining buffer can be comment\n      // Skip if the remaining buffer can be row delimiter\n\n      if (!this.options.rowDelimiter && i + 3 > l || !this._.commenting && l - i < this.options.comment.length && this.options.comment.substr(0, l - i) === remainingBuffer || this.options.rowDelimiter && l - i < this._.rowDelimiterMaxLength && this.options.rowDelimiter.some(function (rd) {\n        return rd.substr(0, l - i) === remainingBuffer; // Skip if the remaining buffer can be row delimiter following the closing quote\n      }) || this.options.rowDelimiter && this._.quoting && l - i < this.options.quote.length + this._.rowDelimiterMaxLength && this.options.rowDelimiter.some(function (rd) {\n        return (_this2.options.quote + rd).substr(0, l - i) === remainingBuffer; // Skip if the remaining buffer can be delimiter\n        // Skip if the remaining buffer can be escape sequence\n      }) || l - i <= this.options.delimiter.length && this.options.delimiter.substr(0, l - i) === remainingBuffer || l - i <= this.options.escape.length && this.options.escape.substr(0, l - i) === remainingBuffer) {\n        break;\n      }\n    }\n\n    char = this._.nextChar ? this._.nextChar : chars.charAt(i);\n    this._.nextChar = l > i + 1 ? chars.charAt(i + 1) : null;\n\n    if (this.options.raw) {\n      this._.rawBuf += char;\n    } // Auto discovery of rowDelimiter, unix, mac and windows supported\n\n\n    if (this.options.rowDelimiter == null) {\n      nextCharPos = i;\n      rowDelimiter = null; // First empty line\n\n      if (!this._.quoting && (char === '\\n' || char === '\\r')) {\n        rowDelimiter = char;\n        nextCharPos += 1;\n      } else if (this._.quoting && char === this.options.quote && ((ref = this._.nextChar) === '\\n' || ref === '\\r')) {\n        rowDelimiter = this._.nextChar;\n        nextCharPos += 2;\n      }\n\n      if (rowDelimiter) {\n        if (rowDelimiter === '\\r' && chars.charAt(nextCharPos) === '\\n') {\n          rowDelimiter += '\\n';\n        }\n\n        this.options.rowDelimiter = [rowDelimiter];\n        this._.rowDelimiterMaxLength = rowDelimiter.length;\n      }\n    } // Parse that damn char\n    // Note, shouldn't we have sth like chars.substr(i, @options.escape.length)\n\n\n    if (!this._.commenting && char === this.options.escape) {\n      // Make sure the escape is really here for escaping:\n      // If escape is same as quote, and escape is first char of a field \n      // and it's not quoted, then it is a quote\n      // Next char should be an escape or a quote\n      escapeIsQuote = this.options.escape === this.options.quote;\n      isEscape = this._.nextChar === this.options.escape;\n      isQuote = this._.nextChar === this.options.quote;\n\n      if (!(escapeIsQuote && !this._.field && !this._.quoting) && (isEscape || isQuote)) {\n        i++;\n        char = this._.nextChar;\n        this._.nextChar = chars.charAt(i + 1);\n\n        if (this._.field == null) {\n          this._.field = '';\n        }\n\n        this._.field += char; // Since we're skipping the next one, better add it now if in raw mode.\n\n        if (this.options.raw) {\n          this._.rawBuf += char;\n        }\n\n        i++;\n        continue;\n      }\n    } // Char match quote\n\n\n    if (!this._.commenting && char === this.options.quote) {\n      if (this._.acceptOnlyEmptyChars && char !== ' ' && char !== '\\t') {\n        return this.error('Only trimable characters are accepted after quotes');\n      }\n\n      if (this._.quoting) {\n        // Make sure a closing quote is followed by a delimiter\n        // If we have a next character and \n        // it isnt a rowDelimiter and \n        // it isnt an column delimiter and\n        // it isnt the begining of a comment\n        // Otherwise, if this is not \"relax\" mode, throw an error\n        isNextCharTrimable = rtrim && ((ref1 = this._.nextChar) === ' ' || ref1 === '\\t');\n        areNextCharsRowDelimiters = this.options.rowDelimiter && this.options.rowDelimiter.some(function (rd) {\n          return chars.substr(i + 1, rd.length) === rd;\n        });\n        areNextCharsDelimiter = chars.substr(i + 1, this.options.delimiter.length) === this.options.delimiter;\n        isNextCharAComment = this._.nextChar === this.options.comment;\n\n        if (this._.nextChar != null && !isNextCharTrimable && !areNextCharsRowDelimiters && !areNextCharsDelimiter && !isNextCharAComment) {\n          if (this.options.relax) {\n            this._.quoting = false;\n\n            if (this._.field) {\n              this._.field = \"\".concat(this.options.quote).concat(this._.field);\n            }\n          } else {\n            if (err = this.error(\"Invalid closing quote at line \".concat(this.lines + 1, \"; found \").concat(JSON.stringify(this._.nextChar), \" instead of delimiter \").concat(JSON.stringify(this.options.delimiter)))) {\n              return err;\n            }\n          }\n        } else if (this._.nextChar != null && isNextCharTrimable) {\n          i++;\n          this._.quoting = false;\n          this._.closingQuote = this.options.quote.length;\n          this._.acceptOnlyEmptyChars = true;\n          continue;\n        } else {\n          i++;\n          this._.quoting = false;\n          this._.closingQuote = this.options.quote.length;\n\n          if (end && i === l) {\n            this._.line.push(cast(this._.field || ''));\n\n            this._.field = null;\n          }\n\n          continue;\n        }\n      } else if (!this._.field) {\n        this._.quoting = true;\n        i++;\n        continue;\n      } else if (this._.field != null && !this.options.relax) {\n        if (err = this.error(\"Invalid opening quote at line \".concat(this.lines + 1))) {\n          return err;\n        }\n      }\n    } // Otherwise, treat quote as a regular character\n\n\n    isRowDelimiter = this.options.rowDelimiter && this.options.rowDelimiter.some(function (rd) {\n      return chars.substr(i, rd.length) === rd;\n    });\n\n    if (isRowDelimiter || end && i === l - 1) {\n      this.lines++;\n    } // Set the commenting flag\n\n\n    wasCommenting = false;\n\n    if (!this._.commenting && !this._.quoting && this.options.comment && chars.substr(i, this.options.comment.length) === this.options.comment) {\n      this._.commenting = true;\n    } else if (this._.commenting && isRowDelimiter) {\n      wasCommenting = true;\n      this._.commenting = false;\n    }\n\n    isDelimiter = chars.substr(i, this.options.delimiter.length) === this.options.delimiter;\n\n    if (this._.acceptOnlyEmptyChars) {\n      if (isDelimiter || isRowDelimiter) {\n        this._.acceptOnlyEmptyChars = false;\n      } else {\n        if (char === ' ' || char === '\\t') {\n          i++;\n          continue;\n        } else {\n          return this.error('Only trimable characters are accepted after quotes');\n        }\n      }\n    }\n\n    if (!this._.commenting && !this._.quoting && (isDelimiter || isRowDelimiter)) {\n      if (isRowDelimiter) {\n        isRowDelimiterLength = this.options.rowDelimiter.filter(function (rd) {\n          return chars.substr(i, rd.length) === rd;\n        })[0].length;\n      } // Empty lines\n\n\n      if (isRowDelimiter && this._.line.length === 0 && this._.field == null) {\n        if (wasCommenting || this.options.skip_empty_lines) {\n          i += isRowDelimiterLength;\n          this._.nextChar = chars.charAt(i);\n          continue;\n        }\n      }\n\n      if (rtrim) {\n        if (!this._.closingQuote) {\n          this._.field = (ref2 = this._.field) != null ? ref2.trimRight() : void 0;\n        }\n      }\n\n      this._.line.push(cast(this._.field || ''));\n\n      this._.closingQuote = 0;\n      this._.field = null; // End of field\n      // Ensure that the delimiter doesnt match as well the rowDelimiter\n\n      if (isDelimiter && !isRowDelimiter) {\n        i += this.options.delimiter.length;\n        this._.nextChar = chars.charAt(i);\n\n        if (end && !this._.nextChar) {\n          isRowDelimiter = true;\n\n          this._.line.push('');\n        }\n      }\n\n      if (isRowDelimiter) {\n        // End of record\n        if (!this._.lineHasError) {\n          err = this.__push(this._.line);\n\n          if (err) {\n            return err;\n          }\n        }\n\n        if (this._.lineHasError) {\n          this._.lineHasError = false;\n        } // Some cleanup for the next record\n\n\n        this._.line = [];\n        i += isRowDelimiterLength;\n        this._.nextChar = chars.charAt(i);\n        continue;\n      }\n    } else if (!this._.commenting && !this._.quoting && (char === ' ' || char === '\\t')) {\n      if (this._.field == null) {\n        // Left trim unless we are quoting or field already filled\n        this._.field = '';\n      }\n\n      if (!(ltrim && !this._.field)) {\n        this._.field += char;\n      }\n\n      i++;\n    } else if (!this._.commenting) {\n      if (this._.field == null) {\n        this._.field = '';\n      }\n\n      this._.field += char;\n      i++;\n    } else {\n      i++;\n    }\n\n    if (!this._.commenting && ((ref3 = this._.field) != null ? ref3.length : void 0) > this.options.max_limit_on_data_read) {\n      return Error(\"Field exceeds max_limit_on_data_read setting (\".concat(this.options.max_limit_on_data_read, \") \").concat(JSON.stringify(this.options.delimiter)));\n    }\n\n    if (!this._.commenting && ((ref4 = this._.line) != null ? ref4.length : void 0) > this.options.max_limit_on_data_read) {\n      return Error(\"Row delimiter not found in the file \".concat(JSON.stringify(this.options.rowDelimiter)));\n    }\n  } // Flush remaining fields and lines\n\n\n  if (end) {\n    if (l === 0) {\n      this.lines++;\n    }\n\n    if (this._.field != null) {\n      if (rtrim) {\n        if (!this._.closingQuote) {\n          this._.field = (ref5 = this._.field) != null ? ref5.trimRight() : void 0;\n        }\n      }\n\n      this._.line.push(cast(this._.field || ''));\n\n      this._.field = null;\n    }\n\n    if (((ref6 = this._.field) != null ? ref6.length : void 0) > this.options.max_limit_on_data_read) {\n      return Error(\"Delimiter not found in the file \".concat(JSON.stringify(this.options.delimiter)));\n    }\n\n    if (this._.line.length > this.options.max_limit_on_data_read) {\n      return Error(\"Row delimiter not found in the file \".concat(JSON.stringify(this.options.rowDelimiter)));\n    }\n  } // Store un-parsed chars for next call\n\n\n  this._.buf = chars.substr(i);\n  return null;\n};\n\nParser.prototype.error = function (msg) {\n  var err;\n  err = Error(msg);\n\n  if (!this.options.skip_lines_with_error) {\n    return err;\n  } else {\n    if (!this._.lineHasError) {\n      this._.lineHasError = true;\n      this.emit('skip', err);\n    }\n  }\n\n  return null;\n}; // ## Utils\n\n\nisObjLiteral = function isObjLiteral(_obj) {\n  var _test;\n\n  _test = _obj;\n\n  if (typeof _obj !== 'object' || _obj === null || Array.isArray(_obj)) {\n    return false;\n  } else {\n    return function () {\n      while (!false) {\n        if (Object.getPrototypeOf(_test = Object.getPrototypeOf(_test)) === null) {\n          break;\n        }\n      }\n\n      return Object.getPrototypeOf(_obj === _test);\n    }();\n  }\n};","map":null,"metadata":{},"sourceType":"script"}